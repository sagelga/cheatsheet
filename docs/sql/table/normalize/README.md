# Normalization
การพัฒนาระบบฐานข้อมูลควรที่จะ ทำให้ข้อมูลเกิดการซ้ำซ้อนน้อยที่สุด เพราะข้อมูลที่ซ้ำซ้อนกัน อาจจะทำให้เกิดความผิดพลาดในการ
- **Insert Anomalies**<br/> การเพิ่มข้อมูลใหม่อาจจะไม่สามารถทำได้ ตัวอย่างเช่น รีเลชัน EMPLOYEE ในรูปที่ 7.2 มีคีย์หลักประกอบด้วย 2 แอตทริบิวต์ คือ Emp_id และ Dep_Id ดังนั้น ถ้ามีพนักงานใหม่เข้ามาและยังไม่ได้กำหนดให้ทำงานในส่วนงานใด ก็จะยังใส่เข้าข้อมูลพนักงานไม่ได้ (คีย์หลักต้องไม่เป็นค่าว่าง) ในทางตรงกันข้ามกัน ถ้าเพิ่มส่วนงานใหม่ขึ้นมาแต่ยังไม่มีพนักงาน ก็จะไม่สามารถใส่ข้อมูลได้เช่นกัน
- **Delete Anomalies**<br/> ความผิดพลาดอาจจะเกิดขึ้นเมื่อมีการลบข้อมูล ตัวอย่างเช่น ถ้าพนักงานคนสุดท้ายในส่วนงานหนึ่งลาออก และได้ลบข้อมูลพนักงาน (ทูเพิล) นั้น ข้อมูลส่วนงานก็จะถูกลบไปด้วยเช่นกัน ทั้งๆ ที่ส่วนงานยังมีอยู่
- **Modification Anomalies**<br/> เมื่อมีการแก้ไขข้อมูลเดียวกันซึ่งเก็บอยู่หลายๆ ที่ อาจทำให้ข้อมูลไม่สอดคล้องกันได้ ตัวอย่างเช่น ข้อมูลของส่วนงานหนึ่งๆ ในรีเลชัน EMPLOYEE (รูปที่ 7.2) จะถูกเก็บซ้ำกันทุกครั้งที่มีพนักงานเพิ่มในสวนงานนั้นๆ ซึ่งถ้ามีการแก้ไขข้อมูลของส่วนงาน เช่น เปลี่ยนชื่อส่วนงาน ก็ต้องทำการแก้ไขทุกข้อมูลของส่วนงานนั้น ซึ่งอาจจะทำการแก้ไขไม่ครบถ้วนหรือแก้ไขไม่ตรงกันได้
- **Reduce Null Values**<br/> ถ้ามี attribute มากเกินไป อาจจะทำให้ข้อมูลไม่เข้ากับ Tuple ทำให้ต้องใส่ค่าว่าง แล้วอาจจะทำให้เกิดการจัดเก็บ การตีความหมาย และการใช้ตัวดำเนินการไม่ได้

## สรุปการทำ Normalization
| Normal Form | Criteria Test                                                               | Normalization                                                                                                                                                                                 |
| ----------- | --------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1NF         | - ไม่มี multivalued atttibutes<br>- ไม่มี composite attributes                  | สร้างรีเลชันสำหรับแต่ละ multivalued atttibutes โดยใช้ primary key ในรีเลชันเดิม เป็น primary key ร่วมกับในรีเลชันใหม่ ในกรณีมี composite attribute ให้แตก composite attributes เป็น single attributes อยู่ในรีเลชันนั้น |
| 2NF         | - ไม่มี Non-key ใดๆ ขึ้นอยู่กับ Partial Key ในตารางที่ Composite Key เป็น Primary Key | แตกรีเลชัน และสร้างรีเลชันใหม่สำหรับแต่ละ partial key กับ attribute ที่ partial key นั้น determine โดยที่ในรีเลชันเดิมยังคงมีแอตทริบิวต์ที่เป็น partial key อยู่                                                           |
| 3NF         | - ไม่มี Non-Key Attribute อธิบาย Non-Key Attribute อื่น                          | ต้องแตกรีเลชัน และสร้างรีเลชันใหม่ที่ประกอบด้วยแอตทริบิวต์ nonkey ที่มีความสัมพันธ์กัน โดยมี determinant เป็น primary key (คง FK ในรีเลชันเดิม)                                                                        |
| BCNF        | - ไม่มี Non-Key Attribute อธิบาย Partial key                                   | ต้องแตกรีเลชัน และสร้างรีเลชันใหม่ที่ประกอบด้วยแอตทริบิวต์ nonkey นั้นๆ (ไปเป็น primary key ในรีเลชันใหม่) และ partial key ที่ถูก determine สำหรับรีเลชันเดิม ให้ใช้ nonkey นั้น ไปเป็น partial key แทนแอตทริบิวต์เดิม            |
| 4NF         | - ไม่มี multivalued dependency                                                | ต้องแตกรีเลชันตาม multivalued dependency                                                                                                                                                         |

## Word Appendix
**Super Key**
เป็นกลุ่ม attribute ที่ไว้ใช้บอก tuple

**Candidate Key (Key Attribute)**
เป็น key ที่จะต้องใช้ เพื่ออธิบาย attribute<br>
เป็นเหมือน Minimal Super Key

**Prime Attribute**
Present in any candidate key

**Non-Prime Attribute**
Not present in candidate key
เป็น attribute ที่ต้องการ key เพื่อให้อธิบายตัวมันเองได้

**Transitive Dependency**
เกิดเมื่อ non-key attribute อธิบาย non-key attribute ได้
ทำให้ key ต้องทำการผ่าน non-key attribute นั้นก่อนเพื่อให้ไปเรียกอีกข้อมูลนึงที่เป็น non-prime attribute
่
เช่น X อธิบาย Y
Y อธิบาย Z

หมายความว่า X อธิบาย Z ได้
